name: Deploy to Yandex Cloud

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      YC_FOLDER_ID: ${{ secrets.YC_FOLDER_ID }}
      YC_CLOUD_ID:  ${{ secrets.YC_CLOUD_ID }}
      WEB_BUCKET:   ${{ secrets.WEB_BUCKET }}
      S3_ENDPOINT:  ${{ secrets.S3_ENDPOINT }}
      BOT_TOKEN:    ${{ secrets.BOT_TOKEN }}
      APIGW_NAME:   ${{ secrets.APIGW_NAME }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate required secrets
        run: |
          test -n "${{ secrets.YC_FOLDER_ID }}"  || (echo "YC_FOLDER_ID is empty" && exit 1)
          test -n "${{ secrets.YC_CLOUD_ID }}"   || (echo "YC_CLOUD_ID is empty" && exit 1)
          test -n "${{ secrets.APIGW_NAME }}"    || (echo "APIGW_NAME is empty" && exit 1)
          test -n "${{ secrets.WEB_BUCKET }}"    || (echo "WEB_BUCKET is empty" && exit 1)
          test -n "${{ secrets.S3_ACCESS_KEY_ID }}"     || (echo "S3_ACCESS_KEY_ID is empty" && exit 1)
          test -n "${{ secrets.S3_SECRET_ACCESS_KEY }}" || (echo "S3_SECRET_ACCESS_KEY is empty" && exit 1)
          test -n "${{ secrets.YC_SA_JSON }}"    || (echo "YC_SA_JSON is empty" && exit 1)

      - name: Echo env
        run: |
          echo "APIGW_NAME=${{ secrets.APIGW_NAME }}"
          echo "WEB_BUCKET=${{ secrets.WEB_BUCKET }}"

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      # ---------- Install YC CLI (без внешних GitHub Actions) ----------
      - name: Install YC CLI
        run: |
          curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash -s -- -i $HOME/yandex-cloud -n
          echo "$HOME/yandex-cloud/bin" >> $GITHUB_PATH
          $HOME/yandex-cloud/bin/yc version

      - name: YC auth
        env:
          YC_SA_JSON: ${{ secrets.YC_SA_JSON }}
        run: |
          echo "$YC_SA_JSON" > key.json
          yc config set service-account-key key.json
          yc config set folder-id $YC_FOLDER_ID
          yc config set cloud-id  $YC_CLOUD_ID
          rm -f key.json

      - name: Verify YC folder access
        run: |
          yc resource-manager folder get "$YC_FOLDER_ID" >/dev/null

      - name: Extract service account id
        id: sa
        env:
          YC_SA_JSON: ${{ secrets.YC_SA_JSON }}
        run: |
          set -euo pipefail
          SA_ID=$(echo "$YC_SA_JSON" | jq -r '.service_account_id')
          if [ -z "$SA_ID" ] || [ "$SA_ID" = "null" ]; then
            echo "Unable to extract service_account_id from YC_SA_JSON" >&2
            exit 1
          fi
          echo "Using service account: $SA_ID"
          echo "id=$SA_ID" >> "$GITHUB_OUTPUT"

      # ---------- Backend: Function ----------
      - uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install server deps
        working-directory: server
        run: |
          if [ -f package-lock.json ]; then
            npm ci
          else
            npm install --no-audit --no-fund
          fi

      - name: Zip server
        run: |
          cd server
          zip -r ../server.zip .

      - name: Ensure function exists
        id: fn
        run: |
          set -e
          retry(){ local n=0; until "$@"; do n=$((n+1)); [ $n -ge 5 ] && return 1; sleep $((n*5)); done; }
          FN_NAME="form-networking-fn"
          if retry yc serverless function get --name "$FN_NAME" >/dev/null 2>&1; then
            echo "exists=1" >> $GITHUB_OUTPUT
          else
            retry yc serverless function create --name "$FN_NAME"
            echo "exists=0" >> $GITHUB_OUTPUT
          fi
          FN_ID=$(retry yc serverless function get --name "$FN_NAME" --format json | jq -r .id)
          echo "id=$FN_ID" >> $GITHUB_OUTPUT

      - name: Ensure service account can invoke function
        run: |
          set -euo pipefail
          retry(){ local n=0; until "$@"; do n=$((n+1)); [ $n -ge 5 ] && return 1; sleep $((n*5)); done; }
          FN_ID="${{ steps.fn.outputs.id }}"
          SA_ID="${{ steps.sa.outputs.id }}"
          SUBJECT="serviceAccount:${SA_ID}"
          ROLE="serverless.functions.invoker"
          BINDINGS=$(retry yc serverless function list-access-bindings --id "$FN_ID" --format json)
          if ! echo "$BINDINGS" | jq -e --arg subject "$SUBJECT" --arg role "$ROLE" 'any(.bindings[]?; .role == $role and .subject == $subject)' >/dev/null; then
            echo "Adding access binding for $SUBJECT"
            retry yc serverless function add-access-binding --id "$FN_ID" --role "$ROLE" --subject "$SUBJECT"
          else
            echo "Access binding for $SUBJECT already exists"
          fi

      - name: Deploy function version
        run: |
          set -e
          retry(){ local n=0; until "$@"; do n=$((n+1)); [ $n -ge 5 ] && return 1; sleep $((n*5)); done; }
          retry yc serverless function version create \
            --function-id  ${{ steps.fn.outputs.id }} \
            --runtime nodejs18 \
            --entrypoint index.handler \
            --memory 128m \
            --execution-timeout 5s \
            --environment BOT_TOKEN=${BOT_TOKEN},DEMO=1 \
            --source-path server.zip

      - name: Make function invokable (public for demo)
        run: |
          FN_ID=${{ steps.fn.outputs.id }}
          # дать публичный инвокер, чтобы API GW мог вызывать без SA
          yc serverless function add-access-binding \
            --id "$FN_ID" \
            --role serverless.functions.invoker \
            --subject allUsers || true

      - name: Wait function ACTIVE
        run: |
          set -euo pipefail
          FN_ID=${{ steps.fn.outputs.id }}
          for i in {1..20}; do
            STATUS=""
            if VERSIONS_JSON=$(yc serverless function version list --function-id "$FN_ID" --format json 2>/dev/null); then
              STATUS=$(echo "$VERSIONS_JSON" | jq -r '.[-1].status' 2>/dev/null || true)
            fi
            if [ -z "$STATUS" ]; then
              STATUS="unknown"
            fi
            echo "Attempt $i: function version status=$STATUS"
            if [ "$STATUS" = "ACTIVE" ]; then
              exit 0
            fi
            sleep 3
          done
          echo "Function version not ACTIVE" >&2
          exit 1

      # ---------- API Gateway ----------
      - name: Prepare OpenAPI with function id
        run: |
          set -euo pipefail
          cp infra/apigw-openapi.yaml apigw.yaml
          sed -i "s|\${FUNCTION_ID}|${{ steps.fn.outputs.id }}|g" apigw.yaml
          if grep -q '\${FUNCTION_ID}' apigw.yaml; then
            echo "FUNCTION_ID placeholder was not replaced" >&2
            exit 1
          fi
          if grep -Eq 'function_id:[[:space:]]*$' apigw.yaml; then
            echo "function_id is empty in apigw.yaml" >&2
            exit 1
          fi
          echo "Prepared API Gateway spec:"
          cat apigw.yaml

      - name: Ensure API Gateway exists (idempotent with backoff)
        id: gw
        env:
          APIGW_NAME: ${{ secrets.APIGW_NAME }}
        run: |
          set -euo pipefail

          retry_with_backoff() {
            local attempt=1
            while [ $attempt -le 5 ]; do
              if "$@"; then
                return 0
              fi
              sleep $((attempt * 3))
              attempt=$((attempt + 1))
            done
            return 1
          }

          if yc serverless api-gateway get --name "$APIGW_NAME" >/dev/null 2>&1; then
            echo "Updating API Gateway '$APIGW_NAME'"
            retry_with_backoff yc serverless api-gateway update --name "$APIGW_NAME" --spec=apigw.yaml
          else
            echo "Creating API Gateway '$APIGW_NAME'"
            retry_with_backoff yc serverless api-gateway create --name "$APIGW_NAME" --spec=apigw.yaml
          fi

          GW_DOMAIN=""
          for attempt in 1 2 3 4 5; do
            if GW_JSON=$(yc serverless api-gateway get --name "$APIGW_NAME" --format json); then
              GW_DOMAIN=$(echo "$GW_JSON" | jq -r '.domain')
              if [ -n "$GW_DOMAIN" ] && [ "$GW_DOMAIN" != "null" ]; then
                break
              fi
            fi
            if [ "$attempt" -eq 5 ]; then
              echo "Failed to fetch API Gateway domain" >&2
              exit 1
            fi
            sleep $((attempt * 3))
          done

          echo "API Gateway domain: https://$GW_DOMAIN"
          echo "url=https://$GW_DOMAIN" >> "$GITHUB_OUTPUT"

      # ---------- Frontend: inject API URL & upload ----------
      - name: Inject API base URL into web/app.js
        run: |
          API_BASE="${{ steps.gw.outputs.url }}"
          sed -i "s|%%API_BASE%%|$API_BASE|g" web/app.js

      - name: Install AWS CLI
        run: |
          pip install --upgrade --user awscli
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Configure AWS credentials (Yandex S3)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.S3_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.S3_SECRET_ACCESS_KEY }}
          aws-region: 'ru-central1'

      - name: Upload web to Object Storage
        run: |
          aws --endpoint-url ${S3_ENDPOINT} s3 sync ./web s3://${WEB_BUCKET} --delete

      - name: Summary
        run: |
          {
            echo "Frontend URL: https://storage.yandexcloud.net/${WEB_BUCKET}/index.html"
            echo "API Base URL : ${{ steps.gw.outputs.url }}"
          } | tee -a "$GITHUB_STEP_SUMMARY"

      - name: Upload YC CLI log
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: yc-cli-log
          path: ~/.config/yandex-cloud/logs/cli.log
          if-no-files-found: ignore

      - name: Upload YC trace logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: yc-traces
          path: /home/runner/.config/yandex-cloud/logs/*.txt
          if-no-files-found: ignore
