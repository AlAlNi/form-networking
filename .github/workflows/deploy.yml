name: Deploy

on:
  push:
    branches:
      - main

permissions:
  id-token: none
  contents: read

env:
  FUNCTION_NAME: ${{ vars.YC_FUNCTION_NAME != '' && vars.YC_FUNCTION_NAME || 'form-networking' }}
  API_GATEWAY_NAME: ${{ vars.YC_API_GATEWAY_NAME != '' && vars.YC_API_GATEWAY_NAME || 'form-networking-gw' }}
  STATIC_BUCKET: ${{ vars.YC_STATIC_BUCKET }}
  DEMO_FLAG: ${{ vars.DEMO_FLAG }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install base tooling
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y zip jq gettext-base
          python3 -m pip install --user --upgrade awscli pyyaml
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Install YC CLI
        run: |
          set -euo pipefail
          curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash
          echo "$HOME/yandex-cloud/bin" >> "$GITHUB_PATH"

      - name: Configure YC CLI
        id: configure
        env:
          YC_SERVICE_ACCOUNT_KEY_B64: ${{ secrets.YC_SERVICE_ACCOUNT_KEY_B64 }}
          YC_CLOUD_ID: ${{ secrets.YC_CLOUD_ID }}
          YC_FOLDER_ID: ${{ secrets.YC_FOLDER_ID }}
        run: |
          set -euo pipefail
          if [ -z "${YC_SERVICE_ACCOUNT_KEY_B64:-}" ]; then
            echo "YC_SERVICE_ACCOUNT_KEY_B64 secret is required" >&2
            exit 1
          fi
          if [ -z "${YC_CLOUD_ID:-}" ]; then
            echo "YC_CLOUD_ID secret is required" >&2
            exit 1
          fi
          if [ -z "${YC_FOLDER_ID:-}" ]; then
            echo "YC_FOLDER_ID secret is required" >&2
            exit 1
          fi
          KEY_FILE="$RUNNER_TEMP/yc-key.json"
          echo "$YC_SERVICE_ACCOUNT_KEY_B64" | base64 --decode > "$KEY_FILE"
          yc config profile create github-deploy >/dev/null 2>&1 || yc config profile activate github-deploy
          yc config set service-account-key "$KEY_FILE"
          yc config set cloud-id "$YC_CLOUD_ID"
          yc config set folder-id "$YC_FOLDER_ID"
          SA_ID=$(jq -r '.service_account_id' "$KEY_FILE")
          echo "service_account_id=$SA_ID" >> "$GITHUB_OUTPUT"
          echo "key_file=$KEY_FILE" >> "$GITHUB_OUTPUT"

      - name: Deploy Cloud Function
        id: deploy-function
        env:
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
          DEMO_FLAG: ${{ env.DEMO_FLAG }}
        run: |
          set -euo pipefail
          if [ -z "${BOT_TOKEN:-}" ]; then
            echo "BOT_TOKEN secret is required" >&2
            exit 1
          fi
          DEMO_VALUE="${DEMO_FLAG:-true}"
          FUNCTION_NAME_VALUE="${FUNCTION_NAME:-form-networking}"
          yc serverless function get --name "$FUNCTION_NAME_VALUE" --format json >"$RUNNER_TEMP/function.json" 2>/dev/null || \
            yc serverless function create --name "$FUNCTION_NAME_VALUE" >/dev/null
          yc serverless function get --name "$FUNCTION_NAME_VALUE" --format json >"$RUNNER_TEMP/function.json"
          FUNCTION_ID=$(jq -r '.id' "$RUNNER_TEMP/function.json")
          echo "Deploying function $FUNCTION_NAME_VALUE ($FUNCTION_ID)"
          yc serverless function version create \
            --function-name "$FUNCTION_NAME_VALUE" \
            --runtime nodejs18 \
            --entrypoint index.handler \
            --memory 128m \
            --execution-timeout 10s \
            --source-path ./server \
            --environment BOT_TOKEN="$BOT_TOKEN" \
            --environment DEMO="$DEMO_VALUE"
          echo "function_id=$FUNCTION_ID" >> "$GITHUB_OUTPUT"
          echo "::notice title=Cloud Function ID::$FUNCTION_ID"

      - name: Deploy API Gateway
        id: deploy-apigw
        env:
          FUNCTION_ID: ${{ steps.deploy-function.outputs.function_id }}
          FUNCTION_INVOKER_SA_ID: ${{ vars.YC_FUNCTION_INVOKER_SA_ID != '' && vars.YC_FUNCTION_INVOKER_SA_ID || steps.configure.outputs.service_account_id }}
          FUNCTION_INVOKER_SA_ID_FROM_VAR: ${{ vars.YC_FUNCTION_INVOKER_SA_ID }}
          FUNCTION_INVOKER_SA_ID_FROM_CONFIGURE: ${{ steps.configure.outputs.service_account_id }}
        run: |
          set -euo pipefail
          if [ -z "${FUNCTION_ID:-}" ]; then
            echo "Function ID is required" >&2
            exit 1
          fi
          if [ -z "${FUNCTION_INVOKER_SA_ID_FROM_VAR:-}" ] && [ -z "${FUNCTION_INVOKER_SA_ID_FROM_CONFIGURE:-}" ]; then
            echo "Function invoker service account ID is required. Set YC_FUNCTION_INVOKER_SA_ID or provide a deployment key with the embedded ID." >&2
            exit 1
          fi
          API_GATEWAY_NAME_VALUE="${API_GATEWAY_NAME:-form-networking-gw}"
          SPEC_FILE="$RUNNER_TEMP/apigw.yaml"
          TEMPLATE_PATH="infra/apigw-openapi.yaml"
          export SPEC_FILE TEMPLATE_PATH
          python3 - <<'PY'
import os
from pathlib import Path

import yaml

function_id = os.environ["FUNCTION_ID"]
invoker_sa_id = os.environ.get("FUNCTION_INVOKER_SA_ID", "").strip()
spec_file = Path(os.environ["SPEC_FILE"])
template_path = Path(os.environ["TEMPLATE_PATH"])

with template_path.open("r", encoding="utf-8") as fh:
    spec = yaml.safe_load(fh)

paths = spec.get("paths", {})
for path_item in paths.values():
    if not isinstance(path_item, dict):
        continue
    for method_spec in path_item.values():
        if not isinstance(method_spec, dict):
            continue
        integration = method_spec.get("x-yc-apigateway-integration")
        if not isinstance(integration, dict):
            continue
        integration["function_id"] = function_id
        if invoker_sa_id:
            integration["service_account_id"] = invoker_sa_id
        else:
            integration.pop("service_account_id", None)

spec_file.parent.mkdir(parents=True, exist_ok=True)
with spec_file.open("w", encoding="utf-8") as fh:
    yaml.safe_dump(spec, fh, sort_keys=False)
PY
          if yc serverless api-gateway get --name "$API_GATEWAY_NAME_VALUE" >/dev/null 2>&1; then
            yc serverless api-gateway update --name "$API_GATEWAY_NAME_VALUE" --spec="$SPEC_FILE" >/dev/null
          else
            yc serverless api-gateway create --name "$API_GATEWAY_NAME_VALUE" --spec="$SPEC_FILE" >/dev/null
          fi
          yc serverless api-gateway get --name "$API_GATEWAY_NAME_VALUE" --format json >"$RUNNER_TEMP/apigw.json"
          GATEWAY_ID=$(jq -r '.id' "$RUNNER_TEMP/apigw.json")
          GATEWAY_DOMAIN=$(jq -r '.domain' "$RUNNER_TEMP/apigw.json")
          API_BASE="https://$GATEWAY_DOMAIN"
          echo "gateway_id=$GATEWAY_ID" >> "$GITHUB_OUTPUT"
          echo "gateway_domain=$GATEWAY_DOMAIN" >> "$GITHUB_OUTPUT"
          echo "api_base=$API_BASE" >> "$GITHUB_OUTPUT"
          echo "::notice title=API Gateway::$API_BASE"

      - name: Publish web app
        id: publish-web
        env:
          API_BASE: ${{ steps.deploy-apigw.outputs.api_base }}
          SA_ID: ${{ steps.configure.outputs.service_account_id }}
        run: |
          set -euo pipefail
          if [ -z "${STATIC_BUCKET:-}" ]; then
            echo "YC_STATIC_BUCKET repository variable is required" >&2
            exit 1
          fi
          if [ -z "${API_BASE:-}" ]; then
            echo "API base URL is missing" >&2
            exit 1
          fi
          WEB_TMP="$(mktemp -d)"
          rsync -a --delete --exclude='.git*' web/ "$WEB_TMP/"
          perl -0pi -e "s|%%API_BASE%%|$API_BASE|g" "$WEB_TMP/app.js"
          ACCESS_KEY_JSON=$(yc iam access-key create --service-account-id "$SA_ID" --description "gh-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}" --format json)
          ACCESS_KEY_ID=$(echo "$ACCESS_KEY_JSON" | jq -r '.access_key.key_id')
          ACCESS_SECRET=$(echo "$ACCESS_KEY_JSON" | jq -r '.secret')
          echo "::add-mask::$ACCESS_SECRET"
          cleanup() {
            yc iam access-key delete --id "$ACCESS_KEY_ID" --quiet
          }
          trap cleanup EXIT
          export AWS_ACCESS_KEY_ID="$ACCESS_KEY_ID"
          export AWS_SECRET_ACCESS_KEY="$ACCESS_SECRET"
          export AWS_DEFAULT_REGION="ru-central1"
          AWS_ENDPOINT="https://storage.yandexcloud.net"
          aws s3api create-bucket --bucket "$STATIC_BUCKET" --endpoint-url "$AWS_ENDPOINT" --create-bucket-configuration LocationConstraint=ru-central1 >/dev/null 2>&1 || true
          aws s3api put-bucket-policy --bucket "$STATIC_BUCKET" --endpoint-url "$AWS_ENDPOINT" --policy "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Principal\":\"*\",\"Action\":[\"s3:GetObject\"],\"Resource\":[\"arn:aws:s3:::${STATIC_BUCKET}/*\"]}]}"
          aws s3api put-bucket-website --bucket "$STATIC_BUCKET" --endpoint-url "$AWS_ENDPOINT" --website-configuration "{\"IndexDocument\":{\"Suffix\":\"index.html\"},\"ErrorDocument\":{\"Key\":\"index.html\"}}"
          aws s3 sync "$WEB_TMP" "s3://$STATIC_BUCKET" --endpoint-url "$AWS_ENDPOINT" --delete --acl public-read --cache-control "public, max-age=60, s-maxage=300"
          STATIC_URL="https://${STATIC_BUCKET}.website.yandexcloud.net"
          echo "static_url=$STATIC_URL" >> "$GITHUB_OUTPUT"
          echo "::notice title=Static site::$STATIC_URL"

      - name: Deployment summary
        run: |
          {
            echo "## Deployment outputs"
            echo
            echo "- Cloud Function ID: ${{ steps.deploy-function.outputs.function_id }}"
            echo "- API Gateway ID: ${{ steps.deploy-apigw.outputs.gateway_id }}"
            echo "- API Gateway domain: ${{ steps.deploy-apigw.outputs.gateway_domain }}"
            echo "- Static hosting URL: ${{ steps.publish-web.outputs.static_url }}"
          } >> "$GITHUB_STEP_SUMMARY"
